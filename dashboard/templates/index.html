<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Avanzata - Analisi Crypto</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        * {
            box-sizing: border-box;
        }

        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            max-width: 1795px; 
            margin: 0 auto;
        }
        .left-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .chart-stack {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            background-color: #1e1e1e;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            padding: 24px;
            display: flex;
            flex-direction: column;
            border: 1px solid #333;
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: scale(1.01);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .card h2 {
            border-bottom: 1px solid #444;
            padding-bottom: 12px;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.15em;
            font-weight: 700;
            color: #ffffff;
            display: flex;
            align-items: center;
            /* MODIFICA: Aggiunto justify-content per separare titolo e select */
            justify-content: space-between; 
            gap: 10px;
        }
        .card h3 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.1em;
            color: #555;
        }
        .chart-container {
            flex-grow: 1;
            position: relative;
            min-height: 250px; 
        }
        
        #header-card {
            padding: 24px;
            /* MODIFICA: Ridotto padding o stile specifico se necessario */
            text-align: center;
        }
        #header-card h2 {
            border-bottom: none;
            margin-bottom: 0; /* Rimosso margine inferiore poich√© non c'√® pi√π la select */
            justify-content: center;
        }

        /* MODIFICA: Stile per la select spostata */
        #sensor-select {
            font-size: 0.9em;
            padding: 6px 12px;
            border-radius: 6px;
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            cursor: pointer;
            outline: none;
        }
        #sensor-select:hover {
            border-color: #777;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 10px;
        }
        .metric-box {
            background: #2a2a2a;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .metric-box.positive {
            border-left-color: #28a745;
        }
        .metric-box.negative {
            border-left-color: #dc3545;
        }
        .metric-box.warning {
            border-left-color: #ffc107;
        }
        .metric-box.danger {
            border-left-color: #dc3545;
        }
        .metric-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 4px;
        }
        .metric-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #ffffff;
        }
        .metric-value.positive {
            color: #28a745;
        }
        .metric-value.negative {
            color: #dc3545;
        }
        
        /* Stato sensore */
        #sensor-status p { margin: 10px 0; font-size: 1.1em; }
        #status-label { display: flex; align-items: center; gap: 10px; }
        
        .status-badge {
            font-size: 0.9em;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 12px;
            color: white;
            text-transform: uppercase;
        }
        .status-online {
            background-color: #28a745;
        }
        .status-offline, .status-error {
            background-color: #dc3545;
        }
        .status-no_data {
            background-color: #6c757d;
        }
        
        #status-temp {
            font-size: 1.2em;
            font-weight: 500;
        }
        
    </style>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<body>

    <div class="container">
        <div class="left-column">
            
            <div class="card" id="header-card">
                <h2>üìä Crypto Analysis Dashboard</h2>
            </div>
            
            <div class="card">
                <h2>
                    <span>üìà Real-Time Status</span>
                    <select id="sensor-select" title="Cambia Criptovaluta">
                        <option value="A1" selected>BTC/USDT</option>
                        <option value="B1">ETH/USDT</option>
                        <option value="C1">SOL/USDT</option>
                    </select>
                </h2>
                <div id="sensor-status">
                    <p id="status-label">Status: <span id="status-badge-text">In attesa...</span></p>
                    <p id="status-temp">Price: N/A</p>
                </div>
            </div>

            <div class="card">
                <h2>üóìÔ∏è Daily Metrics</h2>
                <div id="daily-metrics">
                    <p style="text-align: center; color: #888;">Caricamento...</p>
                </div>
            </div>
            
            <div class="card">
                <h2>‚öôÔ∏è Data Processing Statistics (Batch Layer)</h2>
                <div id="data-stats">
                    <div class="metrics-grid">
                        <div class="metric-box positive">
                            <div class="metric-label">Clean Data (Batch)</div>
                            <div class="metric-value" id="total-clean">0</div>
                        </div>
                        <div class="metric-box danger">
                            <div class="metric-label">Discarded (Batch)</div>
                            <div class="metric-value" id="total-discarded">0</div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 15px; color: #aaa; font-size: 0.9em;">
                        Total Processed (Batch): <span id="total-processed" style="font-weight: bold;">0</span>
                    </div>
                </div>
            </div>
            </div>

        <div class="chart-stack">
            <div class="card">
                <h2>üìâ Real-Time Trend</h2>
                <div class="chart-container" style="min-height:290px;">
                    <canvas id="realtimeLineChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h2>üíæ Memory Usage (RAM)</h2>
                <div class="chart-container" style="min-height: 235px;">
                    <canvas id="memoryChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h2>üåê Network Traffic (I/O)</h2>
                <div class="chart-container" style="min-height: 235px;">
                    <canvas id="networkChart"></canvas>
                </div>
            </div>
            
        </div>
    </div>

    <script>
        let realtimeLineChartInstance;
        let memoryChartInstance;
        let networkChartInstance;
        let lastKnownPrice = null;

        const SENSOR_DETAILS = {
            'A1': { name: 'BTC/USDT', color: 'rgba(242, 169, 0, 1)' },
            'B1': { name: 'ETH/USDT', color: 'rgba(98, 126, 234, 1)' },
            'C1': { name: 'SOL/USDT', color: 'rgba(153, 69, 255, 1)' }
        };

        // --- Chart Defaults (Dark Mode) ---

        function setupChartDefaults() {
            Chart.defaults.color = '#e0e0e0';
            Chart.defaults.borderColor = 'rgba(255, 255, 255, 0.1)';
            Chart.defaults.plugins.legend.labels.color = '#e0e0e0';
            Chart.defaults.scale.ticks.color = '#aaa';
            Chart.defaults.scale.grid.color = 'rgba(255, 255, 255, 0.1)';
            Chart.defaults.scale.title.color = '#e0e0e0';
        }

        function initializeRealtimeLineChart() {
            const ctx = document.getElementById('realtimeLineChart').getContext('2d');
            realtimeLineChartInstance = new Chart(ctx, {
                type: 'line', 
                data: {
                    datasets: [{ 
                        label: 'Price (USD)', 
                        data: [], 
                        borderColor: 'rgba(0, 123, 255, 1)', 
                        tension: 0.1,
                        pointRadius: 0,
                        fill: true, 
                        borderWidth: 2 
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { 
                            title: { display: true, text: 'Price (USD)' },
                            beginAtZero: false, 
                            ticks: { callback: v => '$' + v.toLocaleString() }
                        },
                        x: {
                           type: 'time', 
                           time: {
                                unit: 'hour',
                                stepSize: 1, 
                                tooltipFormat: 'HH:mm',
                                displayFormats: {
                                    hour: 'HH:00'
                                }
                           },
                           title: { display: true, text: 'Time' },
                        }
                    },
                    animation: { duration: 0 } 
                }
            });
        }
        
        function createBarChart(canvasId, yAxisLabel) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: { display: true, text: yAxisLabel },
                            stacked: true
                        },
                        y: {
                            ticks: { autoSkip: false },
                            stacked: true
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'bottom' }
                    }
                }
            });
        }

        function initializePerformanceCharts() {
            memoryChartInstance = createBarChart('memoryChart', 'Memory (MB)');
            memoryChartInstance.data.datasets = [{
                label: 'Used memory (MB)',
                data: [],
                backgroundColor: 'rgba(0, 123, 255, 0.8)',
            }];
            networkChartInstance = createBarChart('networkChart', 'Network Traffic (MB)');
            networkChartInstance.data.datasets = [
                {
                    label: 'Input (Rx)',
                    data: [],
                    backgroundColor: 'rgba(40, 167, 69, 0.8)',
                },
                {
                    label: 'Output (Tx)',
                    data: [],
                    backgroundColor: 'rgba(255, 193, 7, 0.8)',
                }
            ];
        }
        
        // --- Data Update Functions ---

        async function updateRealtimeData(sensorId) {
            const sensorConfig = SENSOR_DETAILS[sensorId];
            try {
                const response = await fetch(`/data/realtime?sensor_id=${sensorId}`); 
                const data = await response.json();
                
                const statusLabelEl = document.getElementById('status-label');
                const statusBadgeEl = document.getElementById('status-badge-text');
                const tempEl = document.getElementById('status-temp');

                if (data.status) {
                    // Rimosso "Crypto X:" dal label dato che ora c'√® la select sopra
                    statusLabelEl.firstChild.textContent = `Status: `;
                    statusBadgeEl.textContent = data.status;
                    statusBadgeEl.className = `status-badge status-${data.status.toLowerCase()}`;
                    
                    let tempText = (data.temp !== 'N/A') ? '$' + parseFloat(data.temp).toLocaleString() : 'N/A';
                    tempEl.textContent = `Price: ${tempText}`;

                    if (lastKnownPrice !== null && lastKnownPrice !== tempText) {
                        tempEl.classList.add('flash-update');
                        setTimeout(() => {
                            tempEl.classList.remove('flash-update');
                        }, 700); 
                    }
                    lastKnownPrice = tempText;
                }
            } catch (error) {
                console.error('Errore fetch realtime:', error);
            }
            
            try {
                const response = await fetch(`/data/realtime/trend?sensor_id=${sensorId}`);
                const data = await response.json(); 
                
                if (realtimeLineChartInstance) {
                    const dataset = realtimeLineChartInstance.data.datasets[0];
                    dataset.data = data.data; 
                    dataset.label = `Price ${sensorConfig.name}`;
                    const baseColor = sensorConfig.color;
                    dataset.borderColor = baseColor;
                    const ctx = realtimeLineChartInstance.ctx;
                    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
                    gradient.addColorStop(0, baseColor.replace('1)', '0.5)')); 
                    gradient.addColorStop(1, baseColor.replace('1)', '0)'));   
                    dataset.backgroundColor = gradient; 
                    realtimeLineChartInstance.options.scales.x.min = data.time_min;
                    realtimeLineChartInstance.options.scales.x.max = data.time_max;
                    realtimeLineChartInstance.update('none');
                }
            } catch (error) {
                console.error('Errore fetch /data/realtime/trend:', error);
            }
        }

        async function updateBatchData(sensorId) {
            const container = document.getElementById('daily-metrics');
            try {
                const response = await fetch(`/data/batch?sensor_id=${sensorId}`);
                
                if (!response.ok) {
                    container.innerHTML = `<p style="text-align: center; color: #dc3545;">Errore API: ${response.statusText}</p>`;
                    return false;
                }

                const data = await response.json();
                
                if (data.status) {
                    container.innerHTML = `<p style="text-align: center; color: #888;">${data.status}</p>`;
                    return false;
                }

                const dates = Object.keys(data);
                if (dates.length === 0) {
                     container.innerHTML = `<p style="text-align: center; color: #888;">Nessun dato aggregato disponibile.</p>`;
                    return false;
                }
                
                const latestDate = dates[dates.length - 1];
                const latestMetrics = data[latestDate];
                updateDailyMetrics(latestMetrics, latestDate);
                return true;

            } catch (error) {
                console.error('Errore fetch batch:', error);
                container.innerHTML = `<p style="text-align: center; color: #dc3545;">Errore: Impossibile caricare i dati batch.</p>`;
                return false;
            }
        }

        function updateDailyMetrics(metrics, date) {
            const container = document.getElementById('daily-metrics');
            const changeClass = metrics.daily_change >= 0 ? 'positive' : 'negative';
            const changeSign = metrics.daily_change >= 0 ? '+' : '';
            container.innerHTML = `
                <div style="text-align: center; margin-bottom: 15px; color: #aaa; font-size: 0.9em;">
                    ${date}
                </div>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-label">Open</div>
                        <div class="metric-value">$${metrics.open.toLocaleString()}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Close</div>
                        <div class="metric-value">$${metrics.close.toLocaleString()}</div>
                    </div>
                    <div class="metric-box ${changeClass}">
                        <div class="metric-label">Variazione</div>
                        <div class="metric-value ${changeClass}">
                            ${changeSign}${metrics.daily_change_pct.toFixed(2)}%
                        </div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Volatilit√†</div>
                        <div class="metric-value">${metrics.volatility.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Min</div>
                        <div class="metric-value">$${metrics.min.toLocaleString()}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Max</div>
                        <div class="metric-value">$${metrics.max.toLocaleString()}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Range</div>
                        <div class="metric-value">${metrics.range_pct.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Osservazioni Pulite</div>
                        <div class="metric-value">${metrics.count}</div>
                    </div>
                </div>
            `;
        }

        async function updateDataStats() {
            let data_agg = {total_clean: 0, total_discarded: 0, total_processed: 0};
            
            try {
                const agg_response = await fetch('/data/aggregate_stats');
                data_agg = await agg_response.json();
                
            } catch (error) {
                console.error('Errore fetch /data/aggregate_stats:', error);
            }
            
            document.getElementById('total-clean').textContent = data_agg.total_clean.toLocaleString();
            document.getElementById('total-discarded').textContent = data_agg.total_discarded.toLocaleString();
            document.getElementById('total-processed').textContent = data_agg.total_processed.toLocaleString();
        }
        
        async function updatePerformanceData() {
            try {
                const response = await fetch('/data/performance');
                const data = await response.json();
                if (data.error) { console.error(data.error); return; }
                const labels = Object.keys(data).sort();
                if (memoryChartInstance) {
                    memoryChartInstance.data.labels = labels;
                    memoryChartInstance.data.datasets[0].data = labels.map(l => data[l].mem_mb);
                    memoryChartInstance.update('none');
                }
                if (networkChartInstance) {
                    networkChartInstance.data.labels = labels;
                    networkChartInstance.data.datasets[0].data = labels.map(l => data[l].net_rx_mb);
                    networkChartInstance.data.datasets[1].data = labels.map(l => data[l].net_tx_mb);
                    networkChartInstance.update('none');
                }
            } catch (error) {
                console.error('Errore fetch /data/performance:', error);
            }
        }

        function updateDashboard() {
            const selectedSensor = document.getElementById('sensor-select').value;
            lastKnownPrice = null; 
            
            updateRealtimeData(selectedSensor);
            updateBatchData(selectedSensor);
            updatePerformanceData();
            updateDataStats();
        }

        window.onload = () => {
            setupChartDefaults();
            initializeRealtimeLineChart();
            initializePerformanceCharts(); 
            
            updateDashboard();
            
            setInterval(() => {
                const selectedSensor = document.getElementById('sensor-select').value;
                updateRealtimeData(selectedSensor);
                updatePerformanceData();
                updateDataStats();
            }, 2000); 

            setInterval(() => {
                const selectedSensor = document.getElementById('sensor-select').value;
                updateBatchData(selectedSensor);
            }, 30000);

            document.getElementById('sensor-select').onchange = updateDashboard;
        };
    </script>
</body>
</html>